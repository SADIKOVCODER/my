__version__ = (2, 0, 0)

#             ‚ñà ‚ñà ‚ñÄ ‚ñà‚ñÑ‚ñÄ ‚ñÑ‚ñÄ‚ñà ‚ñà‚ñÄ‚ñà ‚ñÄ
#             ‚ñà‚ñÄ‚ñà ‚ñà ‚ñà ‚ñà ‚ñà‚ñÄ‚ñà ‚ñà‚ñÄ‚ñÑ ‚ñà
#              ¬© Copyright 2022
#           https://t.me/hikariatama
#
# üîí      Licensed under the GNU AGPLv3
# üåê https://www.gnu.org/licenses/agpl-3.0.html

# meta pic: https://static.hikari.gay/bfg_icon.png
# meta banner: https://mods.hikariatama.ru/badges/bfg.jpg
# meta developer: @sodibio
# scope: hikka_only
# scop: hikka_min 1.3.0

import asyncio
import logging
import time

from telethon import TelegramClient
from telethon.tl.functions.channels import JoinChannelRequest
from telethon.errors.rpcerrorlist import YouBlockedUserError
from telethon.events import NewMessage
from telethon.tl.functions.contacts import UnblockRequest
from telethon.tl.functions.messages import ReadMentionsRequest
from telethon.tl.types import Message

from .. import loader, utils

logger = logging.getLogger(__name__)


class Mining:
    async def _automining(self) -> bool:
        async with self._client.conversation(self._bot) as conv:
            await conv.send_message("–ú–æ—è —à–∞—Ö—Ç–∞")
            r = await conv.get_response()
            mining_exp = int(
                "".join(
                    s
                    for s in r.raw_text.splitlines()[1].split()[2].strip()
                    if s.isdigit()
                )
            )
            self.set("mining_exp", mining_exp)
            energy = int(
                "".join(
                    s
                    for s in r.raw_text.splitlines()[2].split()[2].strip()
                    if s.isdigit()
                )
            )
    async def client_ready(self, client: TelegramClient, _):
        """client_ready hook"""
        await client(JoinChannelRequest(channel=self.strings("author")))
        if energy == 0:
            return False

        resource = next(
            resource
            for range_, resource in self._resources_map.items()
            if mining_exp in range_
        )

        async with self._client.conversation(self._bot) as conv:
            while energy > 0:
                await conv.send_message(f"–∫–æ–ø–∞—Ç—å {resource}")
                r = await conv.get_response()
                if "—É –≤–∞—Å –∑–∞–∫–æ–Ω—á–∏–ª–∞—Å—å" in r.raw_text:
                    break

                if "–≠–Ω–µ—Ä–≥–∏—è" in r.raw_text:
                    energy = int(r.raw_text.split("–≠–Ω–µ—Ä–≥–∏—è:")[1].split(",")[0].strip())

                await asyncio.sleep(0.5)

        return True

    async def _sell_btc(self) -> bool:
        async with self._client.conversation(self._bot) as conv:
            await conv.send_message("–ü—Ä–æ–¥–∞—Ç—å –±–∏—Ç–∫–æ–∏–Ω—ã")
            await conv.get_response()

        return True

    async def _mining_sell(self) -> bool:
        if not self.get("mining_exp"):
            return False

        resources = []
        for range_, resource in self._resources_map.items():
            resources += [resource]
            if self.get("mining_exp") in range_:
                break

        async with self._client.conversation(self._bot) as conv:
            for resource in self._resources_map.values():
                if resource == "–º–∞—Ç–µ—Ä–∏—é":
                    continue

                await conv.send_message(f"–ø—Ä–æ–¥–∞—Ç—å {resource}")
                await conv.get_response()


class Bonuses:
    async def _daily(self):
        async with self._client.conversation(self._bot) as conv:
            await conv.send_message("–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å")
            r = await conv.get_response()
            if "—Ç—ã —É–∂–µ –ø–æ–ª—É—á–∞–ª" not in r.raw_text:
                await asyncio.sleep(2)
                await conv.send_message("–ï–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å")
                r = await conv.get_response()

            hours, minutes = (
                r.raw_text.split("—Ç—ã —Å–º–æ–∂–µ—à—å –ø–æ–ª—É—á–∏—Ç—å —á–µ—Ä–µ–∑")[1].strip().split()
            )
            hours, minutes = int(hours[:-1]), int(minutes[:-1])
            time_ = hours * 60 * 60 + minutes * 60
            self.set("daily", int(time.time() + time_ + 60))
            return True

    async def _treasures(self):
        async with self._client.conversation(self._bot) as conv:
            await conv.send_message("–û–≥—Ä–∞–±–∏—Ç—å –∫–∞–∑–Ω—É")
            await conv.get_response()
            self.set("treasures", int(time.time() + 24 * 60 * 60))


class Potions:
    async def _create_poisons(self) -> bool:
        async with self._client.conversation(self._bot) as conv:
            await conv.send_message("–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å")
            r = await conv.get_response()
            if "–ó—ë—Ä–Ω–∞:" not in r.raw_text:
                self.set("poisons", int(time.time() + 30 * 60))
                return False

            grains = int(
                "".join(
                    s
                    for s in r.raw_text.split("–ó—ë—Ä–Ω–∞:")[1].strip().split(" ")[0]
                    if s.isdigit()
                )
            )

            any_ = False

            for _ in range(grains // 40):
                await conv.send_message("–°–æ–∑–¥–∞—Ç—å –∑–µ–ª—å–µ 1")
                await conv.get_response()
                await asyncio.sleep(0.5)
                any_ = True

        if any_:
            self.set("automining", 0)

        self.set("poisons", int(time.time() + 30 * 60))
        return True


@loader.tds
class BFG2Mod(loader.Module, Mining, Bonuses, Potions):
    """Tasks automation for @bforgame_bot"""

    strings = {"name": "BFG"}

    strings_ru = {"_cls_doc": "Farm in @bforgame_bot"}

    _request_timeout = 3
    _last_iter = 0
    _cache = {}
    _resources_map = {
        range(0, 500): "–∂–µ–ª–µ–∑–æ",
        range(500, 2000): "–∑–æ–ª–æ—Ç–æ",
        range(2000, 10000): "–∞–ª–º–∞–∑—ã",
        range(10000, 25000): "–∞–º–µ—Ç–∏—Å—Ç—ã",
        range(25000, 60000): "–∞–∫–≤–∞–º–∞—Ä–∏–Ω",
        range(60000, 100000): "–∏–∑—É–º—Ä—É–¥—ã",
        range(100000, 500000): "–º–∞—Ç–µ—Ä–∏—é",
        range(
            500000, 10**50
        ): "–ø–ª–∞–∑–º—É",  # We don't care about the size of value, bc it's range
    }
    _bot = "@bforgame_bot"

    def __init__(self):
        self.config = loader.ModuleConfig(
            loader.ConfigValue(
                "autodaily",
                True,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–∏—Ä–∞—Ç—å –µ–∂–µ–¥–Ω–µ–≤–Ω—ã–π –±–æ–Ω—É—Å",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "autotreasures",
                True,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≥—Ä–∞–±–∏—Ç—å –º—ç—Ä–∏—é",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "automining",
                True,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∫–æ–ø–∞—Ç—å —à–∞—Ö—Ç—É –∏ –ø—Ä–æ–¥–∞–≤–∞—Ç—å –≤—Å–µ —Ä–µ—Å—É—Ä—Å—ã, –∫—Ä–æ–º–µ –º–∞—Ç–µ—Ä–∏–∏",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "autofarm",
                True,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–∏—Ä–∞—Ç—å –Ω–∞–ª–æ–≥–∏ –∏ –ø—Ä–∏–±—ã–ª—å —Å —Ñ–µ—Ä–º—ã",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "autogarden",
                True,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–∏—Ä–∞—Ç—å –Ω–∞–ª–æ–≥–∏, —Å–æ–±–∏—Ä–∞—Ç—å –ø—Ä–∏–±—ã–ª—å –∏ –ø–æ–ª–∏–≤–∞—Ç—å —Å–∞–¥",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "autogenerator",
                True,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–∏—Ä–∞—Ç—å –Ω–∞–ª–æ–≥–∏ –∏ –ø—Ä–∏–±—ã–ª—å —Å –±–∏–∑–Ω–µ—Å–∞",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "autobusiness",
                True,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–±–∏—Ä–∞—Ç—å –Ω–∞–ª–æ–≥–∏ –∏ –ø—Ä–∏–±—ã–ª—å —Å –±–∏–∑–Ω–µ—Å–∞",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "autopotions",
                True,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –≤–∞—Ä–∏—Ç—å –∑–µ–ª—å—è",
                validator=loader.validators.Boolean(),
            ),
            loader.ConfigValue(
                "sell_btc",
                False,
                "–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –ø—Ä–æ–¥–∞–≤–∞—Ç—å –±–∏—Ç–∫–æ–∏–Ω—ã",
                validator=loader.validators.Boolean(),
            ),
        )

    async def client_ready(self):
        try:
            await self._client.send_message(
                self._bot,
                "üåö <b> Module BFG runned. \nüë®üèª‚Äçüíª Module By: @Sadiikovv</b>",
            )
        except YouBlockedUserError:
            await self._client(UnblockRequest(self._bot))
            await self._client.send_message(
                self._bot,
                "üåö <b> Module BFG runned. \nüë®üèª‚Äçüíª Module By: @Sadiikovv</b>",
            )

    async def _garden(self) -> bool:
        try:
            message = await self._get_msg("–ú–æ–π —Å–∞–¥")
            if not message:
                return False

            await message.click(data=b"payTaxesGarden")
            await asyncio.sleep(1)
            await message.click(data=b"pourGarden")
            await asyncio.sleep(1)
            await message.click(data=b"collectIncomeGarden")
            return True
        except Exception:
            logger.exception("Can't process BFG click")
            self.set("garden", None)
            return False

    async def _generator(self) -> bool:
        try:
            message = await self._get_msg("–ú–æ–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä")
            if not message:
                return False

            await message.click(data=b"payTaxesGenerator")
            await asyncio.sleep(1)
            await message.click(data=b"collectIncomeGenerator")
            return True
        except Exception:
            logger.exception("Can't process BFG click")
            self.set("generator", None)
            return False

    async def _business(self) -> bool:
        try:
            message = await self._get_msg("–ú–æ–π –±–∏–∑–Ω–µ—Å")
            if not message:
                return False

            await message.click(data=b"payTaxes")
            await asyncio.sleep(1)
            await message.click(data=b"collectIncome")
            return True
        except Exception:
            logger.exception("Can't process BFG click")
            self.set("business", None)
            return False

    async def _farm(self) -> bool:
        try:
            message = await self._get_msg("–ú–æ—è —Ñ–µ—Ä–º–∞")
            if not message:
                return False

            await message.click(data=b"payTaxesFarm")
            await asyncio.sleep(1)
            await message.click(data=b"collectIncomeFarm")
            return True
        except Exception:
            logger.exception("Can't process BFG click")
            self.set("farm", None)
            return False

    async def _get_msg(self, key: str) -> Message:
        async with self._client.conversation(self._bot) as conv:
            await conv.send_message(key)
            r = await conv.get_response()
            if "—á—Ç–æ–±—ã –ø–æ—Å—Ç—Ä–æ–∏—Ç—å –≤–≤–µ–¥–∏—Ç–µ –∫–æ–º–∞–Ω–¥—É" in r.raw_text:
                key = {
                    "–ú–æ–π –≥–µ–Ω–µ—Ä–∞—Ç–æ—Ä": "generator",
                    "–ú–æ—è —Ñ–µ—Ä–º–∞": "farm",
                    "–ú–æ–π —Å–∞–¥": "garden",
                    "–ú–æ–π –±–∏–∑–Ω–µ—Å": "business",
                }[key]
                self.config[f"auto{key}"] = False
                return False

            return r

    @loader.loop(interval=15, autostart=True)
    async def loop(self):
        any_ = False
        if not self.get("fee_time") or self.get("fee_time") < time.time():
            if self.config["autopotions"]:
                await self._create_poisons()
                any_ = True
                await asyncio.sleep(5)

            if self.config["autofarm"]:
                await self._farm()
                any_ = True
                await asyncio.sleep(5)

            if self.config["autogarden"]:
                await self._garden()
                any_ = True
                await asyncio.sleep(5)

            if self.config["autogenerator"]:
                await self._generator()
                any_ = True
                await asyncio.sleep(5)

            if self.config["autobusiness"]:
                await self._business()
                any_ = True
                await asyncio.sleep(5)

            if self.config["automining"]:
                await self._automining()
                await self._mining_sell()
                any_ = True
                await asyncio.sleep(5)

            if self.config["sell_btc"]:
                await self._sell_btc()
                any_ = True
                await asyncio.sleep(5)

            if any_:
                self.set("fee_time", int(time.time() + 60 * 60))

        if self.config["autodaily"] and (
            not self.get("daily") or self.get("daily") < time.time()
        ):
            await self._daily()
            any_ = True
            await asyncio.sleep(5)

        if self.config["autotreasures"] and (
            not self.get("treasures") or self.get("treasures") < time.time()
        ):
            await self._treasures()
            any_ = True

        if any_:
            await self._client(ReadMentionsRequest(self._bot))

    @loader.command(ru_doc="[—É—Ä–æ–≤–Ω–∏] - –ø–æ–∫—É–ø–∫–∞ —É—Ä–æ–≤–Ω–µ–π –¥–ª—è —Ñ–µ—Ä–º—ã")
    async def farmlvlcmd(self, message: Message):
        """[levels] - Level-up farm for specfied amount of levels"""
        args = utils.get_args_raw(message)
        if args and not args.isdigit():
            await utils.answer(message, "üö´ <b>Incorrect number of levels.\nüë®üèª‚Äçüíª Module By: @Sadiikovv</b>")
            return

        message = await utils.answer(message, "üåö <b>Improving the farm</b>")

        levels = 0 if not args else int(args)
        chunk = 0
        enchanced = 0

        while levels:
            async with self._client.conversation(self._bot) as conv:
                await conv.send_message("–ú–æ—è —Ñ–µ—Ä–º–∞")
                r = await conv.get_response()
                if "–í–∏–¥–µ–æ–∫–∞—Ä—Ç—ã: 100" in r.raw_text:
                    await utils.answer(message, "üåö <b>Farm improved to maximum</b>")
                    return

                while chunk < 10 and levels:
                    await r.click(data=b"buyFarmCard")
                    await conv.wait_event(
                        NewMessage(outgoing=False, chats=conv.chat_id)
                    )
                    resp = (await self._client.get_messages(self._bot, limit=1))[0]
                    if "–≤—ã —É—Å–ø–µ—à–Ω–æ —É–≤–µ–ª–∏—á–∏–ª–∏" not in resp.raw_text:
                        await utils.answer(
                            message,
                            (
                                f"üåö <b>The farm has been improved by {enchanced} levels."
                                " Out of money</b>"
                            ),
                        )
                        return

                    enchanced += 1
                    levels -= 1
                    chunk += 1

        await utils.answer(message, f"üåö <b>The farm has been improved by {enchanced} levels.</b>")

    @loader.command(
        ru_doc="[levels] - purchasing levels for a business (territory + business itself)"
    )
    async def businesslvlcmd(self, message: Message):
        """[levels] - Level-up business for specfied amount of levels (territory + business itself)"""
        args = utils.get_args_raw(message)
        if args and not args.isdigit():
            await utils.answer(message, "üö´ <b>Incorrect number of levels</b>")
            return

        message = await utils.answer(message, "üåö <b>Improving business</b>")

        levels = 0 if not args else int(args)
        chunk = 0
        enchanced = 0

        while levels:
            async with self._client.conversation(self._bot) as conv:
                await conv.send_message("–ú–æ–π –±–∏–∑–Ω–µ—Å")
                r = await conv.get_response()
                while chunk < 10 and levels:
                    await r.click(data=b"upTerritory")
                    await conv.wait_event(
                        NewMessage(outgoing=False, chats=conv.chat_id)
                    )
                    resp = (await self._client.get_messages(self._bot, limit=1))[0]
                    if "–≤—ã –¥–æ—Å—Ç–∏–≥–ª–∏ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–≥–æ —Ä–∞–∑–º–µ—Ä–∞" in resp.raw_text:
                        await utils.answer(
                            message,
                            (
                                f"üåö <b>Business improved by {enchanced} levels."
                                " Out of money</b>"
                            ),
                        )
                        return

                    await r.click(data=b"upBusiness")
                    await conv.wait_event(
                        NewMessage(outgoing=False, chats=conv.chat_id)
                    )
                    resp = (await self._client.get_messages(self._bot, limit=1))[0]
                    if "—á—Ç–æ–±—ã —É–≤–µ–ª–∏—á–∏—Ç—å –±–∏–∑–Ω–µ—Å" in resp.raw_text:
                        await utils.answer(
                            message,
                            (
                                f"üåö <b>Business improved by {enchanced} levels."
                                " Out of money</b>"
                            ),
                        )
                        return

                    enchanced += 1
                    levels -= 1
                    chunk += 1

        await utils.answer(message, f"üåö <b>Business improved by {enchanced} levels.</b>")
